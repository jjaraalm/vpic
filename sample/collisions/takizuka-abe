// Demonstrates how to use the Takizuka-Abe collision model to simulate
// an electron beam slowing down in a background plasma.

double
mu(double x) {
  // Computes the definite integral
  //  mu(x) = 2/sqrt(pi) int_0^x sqrt(y) exp(-y) dy

  double dx, x0 = 0, z = 0;
  if(x > 10) {
    x0 = 10;
    z = mu(x0);
  }

  dx = (x-x0)/1000;
  for(int i=0 ; i < 1000 ; ++i) {
    z  += dx*sqrt(x0/M_PI)*exp(-x0);
    x0 += dx;
    z  += dx*sqrt(x0/M_PI)*exp(-x0);
  }
  return z;
}

begin_globals {
  int ncoll;
};

begin_initialization {

  // Simulation parameters

  double mime        = 100;    // Ion to electron mass ratio
  double vthe        = 0.01;   // Electron thermal speed in c
  double Ebeam       = 1;      // Beam energy in Te
  double nbeam       = 0.01;   // Beam density relative to background
  double nu0         = 1e-2;   // Base collision frequency
  double beam_weight = 1;      // Stat. weight of the beam realtive to background
  int nppc           = 100000; // Particles/species/cell in the background
  int ncoll          = 1;      // How often to collide particles in steps
  int nstep          = 10;     // Number of steps to run for

  // Setup
  double dt = 0.98 * courant_length(1, 1, 1, 3, 3, 3);

  define_units( 1, 1 );
  define_timestep( dt );
  define_periodic_grid( 0, 0, 0,   // Grid low corner
                        1, 1, 1,   // Grid high corner
                        3, 3, 3,   // Grid resolution
                        1, 1, 1 ); // Processor configuration
  define_material("vacuum",1.0,1.0,0.0);
  define_field_array();
  set_region_field(everywhere, 0, 0, 0, 0, 0, 0);

  // Define the particle species.        name         q    m   Nmax  Nm Sort In-place
  int Nback = grid->nx*grid->ny*grid->nz * nppc;
  int Nbeam = nbeam*Nback/beam_weight;
  species_t * electron = define_species( "electron", -1,    1, Nback, -1, ncoll, 0 ),
            * ion      = define_species( "ion",       1, mime, Nback, -1, ncoll, 0 ),
            * beam     = define_species( "beam",     -1,    1, Nbeam, -1, ncoll, 0 );


  // Load the particles.
  double weight = 1/Nback;
  double vthi   = vthe / sqrt(mime);
  double vbeam  = 2*sqrt(Ebeam)*vthe;

  repeat(Nback){

    double x = uniform( rng(0), 0, 1 );
    double y = uniform( rng(0), 0, 1 );
    double z = uniform( rng(0), 0, 1 );

    inject_particle( electron, x, y, z,
                     normal(  rng(0), 0, vthe ),
                     normal(  rng(0), 0, vthe ),
                     normal(  rng(0), 0, vthe ),
                     weight, 0, 0 );

    inject_particle( ion, x, y, z,
                     normal(  rng(0), 0, vthi ),
                     normal(  rng(0), 0, vthi ),
                     normal(  rng(0), 0, vthi ),
                     weight, 0, 0 );

  }

  repeat(Nbeam){

    double x = uniform( rng(0), 0, 1 );
    double y = uniform( rng(0), 0, 1 );
    double z = uniform( rng(0), 0, 1 );
    inject_particle( beam, x, y, z, vbeam, 0, 0, weight*beam_weight, 0, 0 );

  }

  // Create the collision operators
  define_collision_op(takizuka_abe("ee_bulk", electron, electron, entropy, nu0, ncoll));
  define_collision_op(takizuka_abe("ei_bulk", electron, ion     , entropy, nu0, ncoll));
  define_collision_op(takizuka_abe("ee_beam", electron, beam    , entropy, nu0, ncoll));
  define_collision_op(takizuka_abe("ei_beam", ion,      beam    , entropy, nu0, ncoll));
  // Ignore beam-beam collisions for benchmarking.

  // Finalize the simulation paramters
  num_step             = nstep;
  status_interval      = 200;
  sync_shared_interval = -status_interval/2;
  clean_div_e_interval = -status_interval/2;
  clean_div_b_interval = -status_interval/2;

  // For informational purposes, compute the theoretical beam energy loss rate.
  // With the normalization conventions used here, this is related to nu0 via
  //
  // nu_e^{e/s} = 4 me/m_s mu(x)/x nu0 (me c^2/Ebeam)^(3/2)
  //
  // where x =  m_s Ebeam / me T and the function
  //
  // mu(x) = 2/sqrt(pi) int_0^x exp(-y) sqrt(y) dy

  // Energy loss rate due to electron collisions.
  double x = Ebeam;
  double nu_e = 4 * mu(x)/x * nu0 * pow(Ebeam*vthe*vthe, -1.5);

  x = Ebeam * mime;
  double nu_i = 4 * mu(x)/x * nu0 * pow(Ebeam*vthe*vthe, -1.5);

  sim_log("Theoretical energy loss rate = " << nu_e + nu_i);

  // Set globals
  global->ncoll = ncoll;

}

begin_diagnostics {

  static double beam_energy = energy_p( find_species("beam"),
                                        interpolator_array );

  if( step() % global->ncoll ) {

    double e    = energy_p(find_species("beam"), interpolator_array);
    double nu_e = (2*(e-beam_energy)/(e+beam_energy))/(grid->dt*global->ncoll);
    sim_log("Beam energy = " << e << ", energy loss rate = " << nu_e);
    beam_energy = e;

  }

}

begin_particle_injection {
}

begin_current_injection {
}

begin_field_injection {
  // Force field to 0 to prevent grid instabilities since dx may be >> Debye
  set_region_field(everywhere, 0, 0, 0, 0, 0, 0);
}

begin_particle_collisions {

}
